{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _values from \"lodash-es/values\";\nimport _get from \"lodash-es/get\";\nimport _has from \"lodash-es/has\";\nimport _forEach from \"lodash-es/forEach\";\nimport _mapValues from \"lodash-es/mapValues\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { getElementType, getUnhandledProps, SUI } from '../../lib';\nimport { getChildMapping, mergeChildMappings } from './utils/childMapping';\nimport wrapChild from './utils/wrapChild';\n/**\n * A Transition.Group animates children as they mount and unmount.\n */\n\nvar TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TransitionGroup, _React$Component);\n\n  function TransitionGroup() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      // Keeping a callback under the state is a hack to make it accessible under getDerivedStateFromProps()\n      handleOnHide: function handleOnHide(nothing, childProps) {\n        var reactKey = childProps.reactKey;\n\n        _this.setState(function (state) {\n          var children = _extends({}, state.children);\n\n          delete children[reactKey];\n          return {\n            children: children\n          };\n        });\n      }\n    };\n    return _this;\n  }\n\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var animation = props.animation,\n        duration = props.duration,\n        directional = props.directional;\n    var prevMapping = state.children; // A short circuit for an initial render as there will be no `prevMapping`\n\n    if (typeof prevMapping === 'undefined') {\n      return {\n        children: _mapValues(getChildMapping(props.children), function (child) {\n          return wrapChild(child, state.handleOnHide, {\n            animation: animation,\n            duration: duration,\n            directional: directional\n          });\n        })\n      };\n    }\n\n    var nextMapping = getChildMapping(props.children);\n    var children = mergeChildMappings(prevMapping, nextMapping);\n\n    _forEach(children, function (child, key) {\n      var hasPrev = _has(prevMapping, key);\n\n      var hasNext = _has(nextMapping, key);\n\n      var prevChild = prevMapping[key];\n      var isLeaving = !_get(prevChild, 'props.visible'); // Heads up!\n      // An item is new (entering), it will be picked from `nextChildren`, so it should be wrapped\n\n      if (hasNext && (!hasPrev || isLeaving)) {\n        children[key] = wrapChild(child, state.handleOnHide, {\n          animation: animation,\n          duration: duration,\n          directional: directional,\n          transitionOnMount: true\n        });\n        return;\n      } // Heads up!\n      // An item is old (exiting), it will be picked from `prevChildren`, so it has been already\n      // wrapped, so should be only updated\n\n\n      if (!hasNext && hasPrev && !isLeaving) {\n        children[key] = /*#__PURE__*/React.cloneElement(prevChild, {\n          visible: false\n        });\n        return;\n      } // Heads up!\n      // An item item hasn't changed transition states, but it will be picked from `nextChildren`,\n      // so we should wrap it again\n\n\n      var _prevChild$props = prevChild.props,\n          visible = _prevChild$props.visible,\n          transitionOnMount = _prevChild$props.transitionOnMount;\n      children[key] = wrapChild(child, state.handleOnHide, {\n        animation: animation,\n        duration: duration,\n        directional: directional,\n        transitionOnMount: transitionOnMount,\n        visible: visible\n      });\n    });\n\n    return {\n      children: children\n    };\n  };\n\n  var _proto = TransitionGroup.prototype;\n\n  _proto.render = function render() {\n    var children = this.state.children;\n    var ElementType = getElementType(TransitionGroup, this.props);\n    var rest = getUnhandledProps(TransitionGroup, this.props);\n    return /*#__PURE__*/React.createElement(ElementType, rest, _values(children));\n  };\n\n  return TransitionGroup;\n}(React.Component);\n\nTransitionGroup.handledProps = [\"animation\", \"as\", \"children\", \"directional\", \"duration\"];\nexport { TransitionGroup as default };\nTransitionGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** An element type to render as (string or function). */\n  as: PropTypes.elementType,\n\n  /** Named animation event to used. Must be defined in CSS. */\n  animation: PropTypes.oneOfType([PropTypes.oneOf(SUI.TRANSITIONS), PropTypes.string]),\n\n  /** Primary content. */\n  children: PropTypes.node,\n\n  /** Whether it is directional animation event or not. Use it only for custom transitions. */\n  directional: PropTypes.bool,\n\n  /** Duration of the CSS transition animation in milliseconds. */\n  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    hide: PropTypes.number.isRequired,\n    show: PropTypes.number.isRequired\n  }), PropTypes.string])\n} : {};\nTransitionGroup.defaultProps = {\n  as: React.Fragment,\n  animation: 'fade',\n  duration: 500\n};","map":{"version":3,"names":["_extends","_inheritsLoose","_values","_get","_has","_forEach","_mapValues","PropTypes","React","getElementType","getUnhandledProps","SUI","getChildMapping","mergeChildMappings","wrapChild","TransitionGroup","_React$Component","_this","_len","arguments","length","args","Array","_key","call","apply","concat","state","handleOnHide","nothing","childProps","reactKey","setState","children","getDerivedStateFromProps","props","animation","duration","directional","prevMapping","child","nextMapping","key","hasPrev","hasNext","prevChild","isLeaving","transitionOnMount","cloneElement","visible","_prevChild$props","_proto","prototype","render","ElementType","rest","createElement","Component","handledProps","default","propTypes","process","env","NODE_ENV","as","elementType","oneOfType","oneOf","TRANSITIONS","string","node","bool","number","shape","hide","isRequired","show","defaultProps","Fragment"],"sources":["C:/Users/Anand Sharma/Desktop/react/my-app/node_modules/semantic-ui-react/dist/es/modules/Transition/TransitionGroup.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _values from \"lodash-es/values\";\nimport _get from \"lodash-es/get\";\nimport _has from \"lodash-es/has\";\nimport _forEach from \"lodash-es/forEach\";\nimport _mapValues from \"lodash-es/mapValues\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { getElementType, getUnhandledProps, SUI } from '../../lib';\nimport { getChildMapping, mergeChildMappings } from './utils/childMapping';\nimport wrapChild from './utils/wrapChild';\n\n/**\n * A Transition.Group animates children as they mount and unmount.\n */\nvar TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TransitionGroup, _React$Component);\n\n  function TransitionGroup() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      // Keeping a callback under the state is a hack to make it accessible under getDerivedStateFromProps()\n      handleOnHide: function handleOnHide(nothing, childProps) {\n        var reactKey = childProps.reactKey;\n\n        _this.setState(function (state) {\n          var children = _extends({}, state.children);\n\n          delete children[reactKey];\n          return {\n            children: children\n          };\n        });\n      }\n    };\n    return _this;\n  }\n\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var animation = props.animation,\n        duration = props.duration,\n        directional = props.directional;\n    var prevMapping = state.children; // A short circuit for an initial render as there will be no `prevMapping`\n\n    if (typeof prevMapping === 'undefined') {\n      return {\n        children: _mapValues(getChildMapping(props.children), function (child) {\n          return wrapChild(child, state.handleOnHide, {\n            animation: animation,\n            duration: duration,\n            directional: directional\n          });\n        })\n      };\n    }\n\n    var nextMapping = getChildMapping(props.children);\n    var children = mergeChildMappings(prevMapping, nextMapping);\n\n    _forEach(children, function (child, key) {\n      var hasPrev = _has(prevMapping, key);\n\n      var hasNext = _has(nextMapping, key);\n\n      var prevChild = prevMapping[key];\n      var isLeaving = !_get(prevChild, 'props.visible'); // Heads up!\n      // An item is new (entering), it will be picked from `nextChildren`, so it should be wrapped\n\n      if (hasNext && (!hasPrev || isLeaving)) {\n        children[key] = wrapChild(child, state.handleOnHide, {\n          animation: animation,\n          duration: duration,\n          directional: directional,\n          transitionOnMount: true\n        });\n        return;\n      } // Heads up!\n      // An item is old (exiting), it will be picked from `prevChildren`, so it has been already\n      // wrapped, so should be only updated\n\n\n      if (!hasNext && hasPrev && !isLeaving) {\n        children[key] = /*#__PURE__*/React.cloneElement(prevChild, {\n          visible: false\n        });\n        return;\n      } // Heads up!\n      // An item item hasn't changed transition states, but it will be picked from `nextChildren`,\n      // so we should wrap it again\n\n\n      var _prevChild$props = prevChild.props,\n          visible = _prevChild$props.visible,\n          transitionOnMount = _prevChild$props.transitionOnMount;\n      children[key] = wrapChild(child, state.handleOnHide, {\n        animation: animation,\n        duration: duration,\n        directional: directional,\n        transitionOnMount: transitionOnMount,\n        visible: visible\n      });\n    });\n\n    return {\n      children: children\n    };\n  };\n\n  var _proto = TransitionGroup.prototype;\n\n  _proto.render = function render() {\n    var children = this.state.children;\n    var ElementType = getElementType(TransitionGroup, this.props);\n    var rest = getUnhandledProps(TransitionGroup, this.props);\n    return /*#__PURE__*/React.createElement(ElementType, rest, _values(children));\n  };\n\n  return TransitionGroup;\n}(React.Component);\n\nTransitionGroup.handledProps = [\"animation\", \"as\", \"children\", \"directional\", \"duration\"];\nexport { TransitionGroup as default };\nTransitionGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** An element type to render as (string or function). */\n  as: PropTypes.elementType,\n\n  /** Named animation event to used. Must be defined in CSS. */\n  animation: PropTypes.oneOfType([PropTypes.oneOf(SUI.TRANSITIONS), PropTypes.string]),\n\n  /** Primary content. */\n  children: PropTypes.node,\n\n  /** Whether it is directional animation event or not. Use it only for custom transitions. */\n  directional: PropTypes.bool,\n\n  /** Duration of the CSS transition animation in milliseconds. */\n  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    hide: PropTypes.number.isRequired,\n    show: PropTypes.number.isRequired\n  }), PropTypes.string])\n} : {};\nTransitionGroup.defaultProps = {\n  as: React.Fragment,\n  animation: 'fade',\n  duration: 500\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}